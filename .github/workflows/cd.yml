name: Continuous Delivery

on:
  push:
    branches: [main]

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Prepare environment file
        run: |
          # Copy .env.example as base template
          cp .env.example .env

          # Replace environment variables using sed - targeting only the key part
          sed -i "s/^APP_NAME=.*/APP_NAME=HRIS/" .env
          sed -i "s/^APP_ENV=.*/APP_ENV=production/" .env
          sed -i "s/^APP_DEBUG=.*/APP_DEBUG=false/" .env
          sed -i "s|^APP_URL=.*|APP_URL=${{ secrets.APP_URL }}|" .env

          # Database configuration - preserve structure, change only values
          sed -i "s/^DB_CONNECTION=.*/DB_CONNECTION=pgsql/" .env
          sed -i "s/^DB_HOST=.*/DB_HOST=host.docker.internal/" .env
          sed -i "s/^DB_PORT=.*/DB_PORT=5432/" .env
          sed -i "s/^DB_DATABASE=.*/DB_DATABASE=${{ secrets.DB_DATABASE }}/" .env
          sed -i "s/^DB_USERNAME=.*/DB_USERNAME=${{ secrets.DB_USERNAME }}/" .env
          sed -i "s/^DB_PASSWORD=.*/DB_PASSWORD=${{ secrets.DB_PASSWORD }}/" .env

          # Add PostgreSQL environment variables (append to end)
          echo "" >> .env
          echo "# PostgreSQL Docker Configuration" >> .env
          echo "POSTGRES_DB=${{ secrets.DB_DATABASE }}" >> .env
          echo "POSTGRES_USER=${{ secrets.DB_USERNAME }}" >> .env
          echo "POSTGRES_PASSWORD=${{ secrets.DB_PASSWORD }}" >> .env

          # Cache and session - only change if different
          sed -i "s/^CACHE_STORE=.*/CACHE_STORE=database/" .env
          sed -i "s/^SESSION_DRIVER=.*/SESSION_DRIVER=database/" .env
          sed -i "s/^QUEUE_CONNECTION=.*/QUEUE_CONNECTION=database/" .env

          # Logging
          sed -i "s/^LOG_LEVEL=.*/LOG_LEVEL=error/" .env

          # Mail configuration (only if secrets are provided)
          if [ -n "${{ secrets.MAIL_MAILER }}" ]; then
            sed -i "s/^MAIL_MAILER=.*/MAIL_MAILER=${{ secrets.MAIL_MAILER }}/" .env
          fi
          if [ -n "${{ secrets.MAIL_HOST }}" ]; then
            sed -i "s/^MAIL_HOST=.*/MAIL_HOST=${{ secrets.MAIL_HOST }}/" .env
          fi
          if [ -n "${{ secrets.MAIL_PORT }}" ]; then
            sed -i "s/^MAIL_PORT=.*/MAIL_PORT=${{ secrets.MAIL_PORT }}/" .env
          fi
          if [ -n "${{ secrets.MAIL_USERNAME }}" ]; then
            sed -i "s/^MAIL_USERNAME=.*/MAIL_USERNAME=${{ secrets.MAIL_USERNAME }}/" .env
          fi
          if [ -n "${{ secrets.MAIL_PASSWORD }}" ]; then
            sed -i "s/^MAIL_PASSWORD=.*/MAIL_PASSWORD=${{ secrets.MAIL_PASSWORD }}/" .env
          fi
          if [ -n "${{ secrets.MAIL_FROM_ADDRESS }}" ]; then
            sed -i "s/^MAIL_FROM_ADDRESS=.*/MAIL_FROM_ADDRESS=\"${{ secrets.MAIL_FROM_ADDRESS }}\"/" .env
          fi

          # Display the modified .env for verification (excluding sensitive data)
          echo "=== Environment Configuration ==="
          echo "APP_NAME: $(grep '^APP_NAME=' .env)"
          echo "APP_ENV: $(grep '^APP_ENV=' .env)"
          echo "DB_CONNECTION: $(grep '^DB_CONNECTION=' .env)"
          echo "DB_HOST: $(grep '^DB_HOST=' .env)"
          echo "DB_PORT: $(grep '^DB_PORT=' .env)"
          echo "DB_DATABASE: $(grep '^DB_DATABASE=' .env)"
          echo "DB_USERNAME: $(grep '^DB_USERNAME=' .env)"
          echo "POSTGRES_DB: $(grep '^POSTGRES_DB=' .env)"
          echo "POSTGRES_USER: $(grep '^POSTGRES_USER=' .env)"
          echo "=== Credential Verification ==="
          if [ "$(grep '^DB_USERNAME=' .env | cut -d'=' -f2)" = "$(grep '^POSTGRES_USER=' .env | cut -d'=' -f2)" ]; then
            echo "✅ DB_USERNAME matches POSTGRES_USER"
          else
            echo "❌ DB_USERNAME does not match POSTGRES_USER"
            echo "DB_USERNAME: $(grep '^DB_USERNAME=' .env | cut -d'=' -f2)"
            echo "POSTGRES_USER: $(grep '^POSTGRES_USER=' .env | cut -d'=' -f2)"
          fi
          if [ "$(grep '^DB_DATABASE=' .env | cut -d'=' -f2)" = "$(grep '^POSTGRES_DB=' .env | cut -d'=' -f2)" ]; then
            echo "✅ DB_DATABASE matches POSTGRES_DB"
          else
            echo "❌ DB_DATABASE does not match POSTGRES_DB"
          fi

      - name: Deploy to server via SSH
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.SERVER_HOST }}
          username: ${{ secrets.SERVER_USER }}
          key: ${{ secrets.SERVER_SSH_KEY }}
          script: |
            cd ./hris
            git checkout origin/patch
            git fetch origin patch
            git pull origin patch

            # Stopping and removing all containers, including orphaned
            docker compose down --remove-orphans

            # Force remove containers to avoid name conflict
            docker rm -f hris-api || true
            docker rm -f hris-postgres || true

            # Clean up old images (optional)
            docker image prune -f

      - name: Copy environment file to server
        uses: appleboy/scp-action@v0.1.7
        with:
          host: ${{ secrets.SERVER_HOST }}
          username: ${{ secrets.SERVER_USER }}
          key: ${{ secrets.SERVER_SSH_KEY }}
          source: ".env"
          target: "./hris-backend/"

      - name: Build and start containers
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.SERVER_HOST }}
          username: ${{ secrets.SERVER_USER }}
          key: ${{ secrets.SERVER_SSH_KEY }}
          script: |
            cd ./hris-backend

            # Verify .env file exists and show database configuration
            if [ -f .env ]; then
              echo "✅ .env file found"
              echo "=== Database Configuration ==="
              echo "DB_CONNECTION: $(grep '^DB_CONNECTION=' .env)"
              echo "DB_HOST: $(grep '^DB_HOST=' .env)"
              echo "DB_PORT: $(grep '^DB_PORT=' .env)"
              echo "DB_DATABASE: $(grep '^DB_DATABASE=' .env)"
              echo "DB_USERNAME: $(grep '^DB_USERNAME=' .env)"
              echo "POSTGRES_DB: $(grep '^POSTGRES_DB=' .env)"
              echo "POSTGRES_USER: $(grep '^POSTGRES_USER=' .env)"
              
              # Verify credentials match
              DB_USER=$(grep '^DB_USERNAME=' .env | cut -d'=' -f2)
              PG_USER=$(grep '^POSTGRES_USER=' .env | cut -d'=' -f2)
              DB_NAME=$(grep '^DB_DATABASE=' .env | cut -d'=' -f2)
              PG_DB=$(grep '^POSTGRES_DB=' .env | cut -d'=' -f2)
              
              if [ "$DB_USER" = "$PG_USER" ] && [ "$DB_NAME" = "$PG_DB" ]; then
                echo "✅ Database credentials are consistent"
              else
                echo "❌ Database credential mismatch detected!"
                echo "DB_USERNAME=$DB_USER vs POSTGRES_USER=$PG_USER"
                echo "DB_DATABASE=$DB_NAME vs POSTGRES_DB=$PG_DB"
              fi
            else
              echo "❌ .env file not found!"
              exit 1
            fi

            # Generate APP_KEY if not set
            if ! grep -q "^APP_KEY=base64:" .env; then
              echo "Generating APP_KEY with artisan..."
              docker compose run --rm -e APP_ENV=production -v $(pwd):/app --workdir /app php php artisan key:generate --force
            fi

            # Building and starting the containers
            docker compose up -d --build

            # Wait for containers to be ready
            sleep 30

            # Check container status
            echo "=== Container Status ==="
            docker compose ps

            # Wait for database to be ready
            echo "=== Waiting for database to be ready ==="
            timeout=60
            while [ $timeout -gt 0 ]; do
              if docker compose exec postgres pg_isready -U $(grep '^POSTGRES_USER=' .env | cut -d'=' -f2) -d $(grep '^POSTGRES_DB=' .env | cut -d'=' -f2) > /dev/null 2>&1; then
                echo "✅ PostgreSQL is ready"
                break
              fi
              echo "Waiting for PostgreSQL... ($timeout seconds remaining)"
              sleep 5
              timeout=$((timeout-5))
            done

            if [ $timeout -le 0 ]; then
              echo "❌ PostgreSQL failed to become ready in time"
              docker compose logs postgres
              exit 1
            fi

            # Test database connection from Laravel
            echo "=== Testing Laravel Database Connection ==="
            if docker compose exec api php artisan migrate:status > /dev/null 2>&1; then
              echo "✅ Laravel can connect to database"
            else
              echo "❌ Laravel cannot connect to database"
              echo "=== Laravel Database Error ==="
              docker compose exec api php artisan migrate:status
              echo "=== PostgreSQL Logs ==="
              docker compose logs postgres --tail=20
              echo "=== Laravel Logs ==="
              docker compose logs api --tail=20
            fi

            # Check logs for any errors
            echo "=== Recent Container Logs ==="
            docker compose logs --tail=50
